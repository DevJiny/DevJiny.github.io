[ { "title": "Datadog on Kubernetes", "url": "/posts/datadog/", "categories": "DevOps, K8S, Datadog", "tags": "K8S, Kubernetes, datadog", "date": "2022-07-14 00:00:00 +0900", "snippet": "Datadog Document Linkhttps://docs.datadoghq.com/containers/kubernetes/installation/?tab=helm&amp;tabs=nullBasic values https://github.com/DataDog/helm-charts/blob/main/examples/datadog/agent_basic_values.yamltargetSystem: \"linux\"datadog: logs: enabled: true containerCollectAll: false# containerCollectUsingFiles: true apm: portEnabled: true socketPath: /var/run/datadog/apm.socket hostSocketPath: /var/run/datadog/ processAgent: enabled: true processCollection: falseHelm Repo Update$ helm repo add datadog https://helm.datadoghq.com$ helm repo updateHelm Install$ helm install datadog -f values.yaml --set datadog.apiKey=YOURKEY datadog/datadogDeployment Add SideCarapiVersion: apps/v1kind: Deploymentmetadata: labels: tags.datadoghq.com/env: \"&lt;environment&gt;\" tags.datadoghq.com/service: \"&lt;service&gt;\" tags.datadoghq.com/version: \"&lt;version&gt;\"spec: template: metadata: labels: tags.datadoghq.com/env: \"&lt;environment&gt;\" tags.datadoghq.com/service: \"&lt;service&gt;\" tags.datadoghq.com/version: \"&lt;version&gt;\" spec: initContainers: - name: download-agent image: busybox command: - wget - -O - /agent/dd-java-agent.jar - https://dtdg.co/latest-java-tracer volumeMounts: - name: agent-volume mountPath: \"/agent\" volumes: # for APM - name: apmsocketpath hostPath: path: /var/run/datadog/ # for log - name: agent-volume emptyDir: { } containers: - name: &lt;CONTAINER_NAME&gt; image: &lt;CONTAINER_IMAGE&gt;/&lt;TAG&gt; volumeMounts: # for APM - name: apmsocketpath mountPath: /var/run/datadog # for log - name: agent-volume mountPath: \"/agent\" env: - name: DD_ENV valueFrom: fieldRef: fieldPath: metadata.labels['tags.datadoghq.com/env'] - name: DD_SERVICE valueFrom: fieldRef: fieldPath: metadata.labels['tags.datadoghq.com/service'] - name: DD_VERSION valueFrom: fieldRef: fieldPath: metadata.labels['tags.datadoghq.com/version']Spring log json appender 추가JSON Format으로 log를 남기자gradle dependency 추가implementation 'net.logstash.logback:logstash-logback-encoder:6.6'logback.xml 추가&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/&gt; &lt;property name=\"LOG_PATH\" value=\"/var/log\"/&gt; &lt;appender name=\"jsonAppender\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"/&gt; &lt;/appender&gt; &lt;appender name=\"stdoutAppender\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt; &lt;charset&gt;utf8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt;&lt;!-- &lt;appender name=\"rollingJsonAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;--&gt;&lt;!-- &lt;file&gt;${LOG_PATH}/application-json.log&lt;/file&gt;--&gt;&lt;!-- &lt;encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"/&gt;--&gt;&lt;!-- &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;--&gt;&lt;!-- &lt;fileNamePattern&gt;${LOG_PATH}/application-json.%d{yyyy-MM-dd}.%i.gz&lt;/fileNamePattern&gt;--&gt;&lt;!-- &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt;--&gt;&lt;!-- &lt;maxFileSize&gt;200MB&lt;/maxFileSize&gt;--&gt;&lt;!-- &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;--&gt;&lt;!-- &lt;maxHistory&gt;7&lt;/maxHistory&gt;--&gt;&lt;!-- &lt;/rollingPolicy&gt;--&gt;&lt;!-- &lt;/appender&gt;--&gt; &lt;springProfile name=\"!prod\"&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"stdoutAppender\"/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;springProfile name=\"prod\"&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"jsonAppender\"/&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt;" }, { "title": "ArgoCD 설치", "url": "/posts/argocd/", "categories": "DevOps, K8S", "tags": "K8S, eksctl, argocd, Kubernetes", "date": "2022-07-14 00:00:00 +0900", "snippet": "Argocd 설치https://argo-cd.readthedocs.io/en/stable/getting_started/$ kubectl create namespace argocd$ kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yamlClient Side Argocd 설치$ brew install argocdDisable internal TLSArgoCD 내부적으로 사용하는 https를 http로 변경 -&gt; TLS 없이 통신 하도록 변경하자kubectl -n argocd edit deployments.apps argocd-server{vim 이 뜸}(before) containers: - command: - argocd-server(after) containers: - command: - argocd-server - --insecureIngress 생성 후 연동apiVersion: networking.k8s.io/v1kind: Ingressmetadata: namespace: argocd name: ingress-argocd annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/listen-ports: '[{\"HTTP\": 80}, {\"HTTPS\":443}]' alb.ingress.kubernetes.io/certificate-arn: { YOUR ARN } alb.ingress.kubernetes.io/healthcheck-path: / alb.ingress.kubernetes.io/healthcheck-protocol: HTTP alb.ingress.kubernetes.io/ssl-redirect: '443' finalizers: - ingress.k8s.aws/resourcesspec: rules: - host: xxx.xxx.com http: paths: - backend: service: name: argocd-server port: number: 80 path: /* pathType: ImplementationSpecificPassword 변경초기 패스 워드 출력 -&gt; 출력된 패스워드로 로그인 -&gt; 패스워드 변경$ kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d; echo{PASSWORD 출력됨}$ argocd login &lt;ARGOCD_SERVER&gt;$ argocd account update-password" }, { "title": "EKS Fargate Cluster with Ingress ALB", "url": "/posts/eks-fargate/", "categories": "DevOps, K8S", "tags": "K8S, eksctl, ingress, Kubernetes", "date": "2022-05-25 00:00:00 +0900", "snippet": "설치$ brew install awscli$ brew install eksctl$ brew install helmAWS CLI Login$ aws configureAWS Access Key ID [None]: xxxAWS Secret Access Key [None]: xxxDefault region name [None]: ap-northeast-2Default output format [None]: jsonEKS Cluster 생성 cluster-fargate.yaml 파일 생성apiVersion: eksctl.io/v1alpha5kind: ClusterConfigmetadata: name: fargate-cluster region: ap-northeast-2fargateProfiles: - name: fc-default selectors: # All workloads in the \"default\" Kubernetes namespace will be # scheduled onto Fargate: - namespace: default # All workloads in the \"kube-system\" Kubernetes namespace will be # scheduled onto Fargate: - namespace: kube-system - name: fc-dev selectors: # All workloads in the \"dev\" Kubernetes namespace matching the following # label selectors will be scheduled onto Fargate: - namespace: dev labels: type: dev ecksctl 명령어로 Cluster 생성$ eksctl create cluster -f cluster-fargate.yamlIAM Policy Setting 및 K8S ServiceAccount 생성AWS 공식 가이드 클러스터가 서비스 계정에 IAM를 사용하도록 허용$ eksctl utils associate-iam-oidc-provider --cluster YOUR_CLUSTER_NAME --approve AWS Load Balancer Controller에서 사용자 대신 AWS API를 호출하는 것을 허용하는 IAM 정책을 다운로드하고 이를 적용 IAM Policy Download $ curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.2.0/docs/install/iam_policy.json IAM Policy Creation $ aws iam create-policy \\ --policy-name AWSLoadBalancerControllerIAMPolicy \\ --policy-document file://iam_policy.json kube-system 네임스페이스에 aws-load-balancer-controller라는 이름의 ServiceAccount 를 생성, 이때 위에서 생성한 Policy도 지정 $ eksctl create iamserviceaccount \\--cluster=YOUR_CLUSTER_NAME \\--namespace=kube-system \\--name=aws-load-balancer-controller \\--attach-policy-arn=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:policy/AWSLoadBalancerControllerIAMPolicy \\--override-existing-serviceaccounts \\--approve 확인 $ eksctl get iamserviceaccount --cluster YOUR_CLUSTER_NAME --name aws-load-balancer-controller --namespace kube-systemor$ kubectl get serviceaccount aws-load-balancer-controller --namespace kube-system AWS Load Balancer Controller 설치 Helm Repository 추가$ helm repo add eks https://aws.github.io/eks-charts TargetGroupBinding CRD 설치$ kubectl apply -k \"github.com/aws/eks-charts/stable/aws-load-balancer-controller//crds?ref=master\" Helm Chart로 LoadBalancer 설치$ helm install aws-load-balancer-controller eks/aws-load-balancer-controller \\ --set clusterName=YOUR_CLUSTER_NAME \\ --set serviceAccount.create=false \\ --set region=YOUR_REGION_CODE \\ --set vpcId=&lt;VPC_ID&gt; \\ --set serviceAccount.name=aws-load-balancer-controller \\ -n kube-systemTest Application 배포로 확인해보기 fargate profile 생성$ eksctl create fargateprofile \\--cluster your-cluster \\--region your-region-code \\--name your-alb-sample-app \\--namespace game-2048 다음 파일을 저장하고, kubectl apply -f 해주자.---apiVersion: v1kind: Namespacemetadata: name: game-2048---apiVersion: apps/v1kind: Deploymentmetadata: namespace: game-2048 name: deployment-2048spec: selector: matchLabels: app.kubernetes.io/name: app-2048 replicas: 1 template: metadata: labels: app.kubernetes.io/name: app-2048 spec: containers: - image: alexwhen/docker-2048 imagePullPolicy: Always name: app-2048 resources: limits: cpu: 1 memory: 1024Mi requests: cpu: 1 memory: 1024Mi ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: namespace: game-2048 name: service-2048spec: ports: - port: 80 targetPort: 80 protocol: TCP type: ClusterIP selector: app.kubernetes.io/name: app-2048---apiVersion: networking.k8s.io/v1kind: Ingressmetadata: namespace: game-2048 name: ingress-2048 annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ipspec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: service-2048 port: number: 80 AWS Console 에서 ALB 가 생성됨을 확인하고, DNS 80포트로 잘뜨는지 확인해보자.R53 -&gt; ALB Ingress, Https 정의법 ACM으로 인증서를 생성해주자. R53의 DNS A Record에 ALB를 바라보게 세팅해 주고, 아래와 같이 생성한다. 해당 Domain으로 https 접속이 잘되고, 80 으로 접속한다면, 443 Redirect 된다.---apiVersion: networking.k8s.io/v1kind: Ingressmetadata: namespace: game-2048 name: ingress-2048 annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 # SSL Settings alb.ingress.kubernetes.io/listen-ports: '[{\"HTTP\": 80}, {\"HTTPS\":443}]' alb.ingress.kubernetes.io/certificate-arn: 'ACM으로 생성된 Certificate ARN' alb.ingress.kubernetes.io/ssl-redirect: '443'spec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: service-2048 port: number: 80" }, { "title": "Kubernetes Cluster의 Master Node에 Pod Deploy 하기", "url": "/posts/use-k8s-master/", "categories": "DevOps, K8S", "tags": "K8S, MasterNode", "date": "2020-06-01 00:00:00 +0900", "snippet": "Preface기본적으로 Kubernetes Master Node에는 Pod가 Deploy 되지 않는다. (보안상의 이유로)만약, Master Node (Control Plane)에 Pod를 Deploy 하고자 한다면, 아래와 같이 실행 한다.$ kubectl taint nodes --all node-role.kubernetes.io/master-Command상기는 명령은 Cluster 내의 모든 Node에서 아래 Taint를 제거 하는것이다. node-role.kubernetes.io/master결과Output은 다음과 같다.node \"test-01\" untaintedtaint \"node-role.kubernetes.io/master:\" not foundtaint \"node-role.kubernetes.io/master:\" not found이후 Scheduler는 Cluster내의 모든 Node에 Pod를 Deploy 한다.원본 링크K8S Doc Link" } ]
